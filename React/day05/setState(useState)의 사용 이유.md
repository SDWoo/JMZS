# 왜 state를 직접 바꾸지 않고 setState (useState)를 사용해야 하나요?

<br />

> 목차

> [동우](#동우)

> [은지](#은지)

> [지연](#지연)

<br />

### 동우

- state는 불변성을 유지해야한다. 그러므로, state를 바뀌면 re-redering을 해야 하는데, 함수형 컴포넌트에서는 state를 직접 바꾸기만 하면 내부적으로 render함수를 실행시켜주지 않는다. setState를 사용하면, 상태를 바꾸고, 내부적으로 리액트 엔진이 render함수를 실행시켜주어 re-rendering이 발생한다.
- 꼬리질문: 그럼 함수형 컴포넌트에서 render는 어떻게 명시적으로 표현되고 있을까요? return() 함수를 통해 미리 구현한 컴포넌트를 표시해준다.
- [출처](https://velog.io/@devmag/React-state-%EB%B3%80%EA%B2%BD-%EC%8B%9C-%EC%99%9C-useState-setState%EB%A5%BC-%EC%93%B0%EB%8A%94%EA%B0%80)
- [함수형 컴포넌트의 라이프 사이클 메소드](https://adjh54.tistory.com/43)

<br />

### 은지

- state는 immutable(불변성)을 유지해야하기 때문에 직접 수정하지 않아야 합니다.
- 컴포넌트는 현재의 this.state와 setState를 비교해서 업데이트가 필요한 경우에만 render 함수를 호출하는데, state를 직접 수정하게 되면 리액트가 render 함수를 호출하지 않아 상태 변경이 일어나도 렌더링이 일어나지 않을 수 있습니다. 상태 변경을 추적하고 변경에 따라 구성요소를 다시 렌더링하려면 setState를 사용해야 합니다.

<br />

### 지연

- state가 불변성을 유지하기 위해서다.
- state는 객체이며, 리액트 컴포넌트는 값의 변경 여부를 확인할 때 객체의 메모리 주소를 확인하게 되는데, 직접 state를 변경하는 경우, 주소의 변화를 확인할 수 없다.
- 따라서, setState를 통해 새로운 객체를 만들고, 해당 객체의 메모리 주소 변경 여부를 확인해 state의 변화를 확인한다.
- 컴포넌트는 this.state와 setState를 비교해 업데이트가 필요한 경우에만 render 함수를 호출하는데, state를 직접 변경하면 리액트가 변화를 감지하지 못해 상태 변경이 이루어져도 렌더링이 일어나지 않는다.

<br />

### 꼬리 질문 모음

- setState를 이용해 상태를 변경해도 해당 상태를 출력하면 바뀐 값이 아니라 기존의 상태값이 출력되는데 그 이유는?
  - setState는 비동기적으로 동작하기 때문이다. 또한 setState는 값을 바로 바꿔주는 것이 아니라 상태를 업데이트하도록 계획하는 것이기 때문이다.
