# Flux 패턴에 대해 설명해주세요.

<br />

> 목차

> [동우](#동우)

> [은지](#은지)

> [지연](#지연)

> [규란](규란)

<br />

### 동우

- MVC 패턴을 이전에 자주 사용했는데 MVC패턴에서는 Controller가 Model에서 정의된 데이터를 조회하거나 업데이트 해주는 역할을 하여 변경된 Model의 데이터를 View에 반영해준다.
- 사용자는 뷰를 통해 데이터를 입력하고 Model에 반영됩니다.
- 이렇게 Model과 View 사이에 양방향 데이터 소통이 일어나는데, 이 패턴은 규모가 커질수록 수많은 VIew와 Model이 생겨나게 되고, 데이터의 흐름을 파악하기 어려웠습니다.
- 새 기능을 추가할 때마다 크고작은 문제가 생겼을 때, 문제를 파악하기 힘들어 지며 사이드 이펙트가 발생했다.
- 그래서 이러한 문제를 해결하기 위해 Flux 패턴이 나왔다.
- Action이 발생하면 dispatcher에 의해 store에 변경된 사항이 저장되고, 그 저장된 데이터들에 의해 view가 변경되는 단방향 데이터 흐름입니다.
- 이렇게 단방향으로 데이터가 흐르게 되면 흐름을 훨씬 파악하기 쉽고 예측 가능하다는 큰 장점이 있습니다.

<br />

### 은지

- 페이스북 설계 팀은 기존의 MVC의 한계인 데이터 흐름을 예측할 수 없음을 해결하기 위해 양방향 데이터 흐름을 단방향 데이터 흐름인 Flux 패턴을 만들어냈다.
- Flux는 사용자 입력을 기반으로 Action을 만들고 Action을 Dispatcher에 전달하여 Store(Model)의 데이터를 변경한 뒤 View에 반영하는 단방향의 흐름으로 애플리케이션을 만드는 아키텍처입니다.

<br />

### 지연

- 사용자 입력을 기반으로 action을 만들고, 해당 action을 dispatcher에 전달해 store의 데이터를 변경한 뒤 view에 반영하는 단방향의 흐름으로 어플리케이션을 만드는 아키텍쳐

<br />

### 규란

- flux 아키텍처란 리액트에서 상태를 어떻게
- 2014년 페이스북 F8 컨퍼런스에서 발표된 아키텍처로, Client-Side 웹 애플리케이션을 만들기 위해 사용하는 디자인 패턴입니다.
- 사용자 입력을 기반으로 Action을 만들고
  Action을 Dispatcher에 전달하여
  Store의 데이터를 변경한 뒤
  View에 반영하는 단방향의 흐름으로 애플리케이션을 만듭니다.![[Pasted image 20230212170158.png]]
- flux 애플리케이션은 크게 dispatcher, stores, views 3가지 부분으로 구성됩니다.

  - 최상위에서 controller-views / views 관계로 controller가 존재한다.
  - controller-views : stores에서 데이터를 가져와 그 데이터를 자식에게 보내는 역할을 한다.

- Action

  - 데이터를 변경하는 행위로서, dispatcher에게 전달되는 객체를 뜻합니다.
  - action creator 메서드를 통해 전달되는데, 새로 발생한 action의 type, 새로운 데이터 payload를 묶어 dispatcher에게 전달합니다.

- Dispatcher

  - 모든 데이터의 흐름을 관리하는 중앙 허브입니다.
  - Dispatcher에는 Store들이 등록해놓은 Action 타입마다의 콜백 함수들이 존재해서, action을 감지하면 Store들이 각 타입에 맞는 콜백함수를 실행한다.
  - Store의 데이터 조작은 오직 dispatcher를 통해서만 가능하다.

- Store

  - 상태 저장소이다.
  - 상태, 상태를 변경할 수 있는 메서드를 가진다.
  - 발생한 Action 타입에 따라 데이터를 변경하는 콜백함수를 dispatcher에 등록한다.

- View

  - React의 컴포넌트라고 생각하면 되는데, 최상위 controller view는 store에서 데이터를 가져와 자식 view에게 내려보낸다.
  - 새로운 데이터를 받은 view는 리렌더링한다.
  - 사용자가 View에 어떤한 조작을 하면 그에 해당하는 Action을 생성합니다.

- 전체적인 흐름
  - view에서 사용자가 상호작용을 하면
    1. 중앙의 dispatcher를 통해 action을 전파한다.
    - action은 새로운 데이터를 포함하고 있는 간단한 객체로, type 프로퍼티로 구분할 수 있다.
    2. action이 전파되면 store는 해당 action에 영향이 있는 모든 view를 갱신한다.
    - store는 애플리케이션의 데이터와 비지니스 로직을 가지고 있다.
      +) MVC가 가지는 복잡성을 해결하기 위해 페이스북에서 만든 단방향 데이터 흐름 웹 애플리케이션 아키텍처

<br />

### 꼬리 질문 모음

- **꼬리 질문 1 - Flux와 redux의 차이점은 ?**

  - Hot Reloading 방식을 사용한다. 즉 코드가 변경되어도 기존의 상태를 유지할 수 있게 만들어준다는 것이다. Flux 패턴의 첫번째 문제점은 상태 업데이트에 관련된 코드를 리로딩 하게 되면 애플리케이션 상태도 같이 리로딩되어 저장된 상태 정보를 잃어버리게 되는 것이였다. 이것은 store에서 상태 변환을 위한 로직과 상태 두가지의 역할을 모두 갖고 있기 떄문에 발생하는 문제였는데, redux는 상태는 store에서, 상태 변환을 위한 로직은 reducer로 관리하여 상태 업데이트 코드 리로딩시 리듀서만 리로딩되기 때문에 상태를 잃어버리지 않는다.
  - Time Travel Debugging(시간 여행 디버깅)을 사용할 수 있다. 이전 상태로 되돌아갈 수 있다는 것이다. 리덕스에서는 상태를 업데이트 할떄 상태의 복사본을 수정하는 식으로 불변성을 유지시킨다. Flux에서도 구현은 가능하지만 상당히 복잡한 반면 redux 에서는 아주 간단히 처리할 수 있다.

- **꼬리 질문 2 - Flux 패턴 등장 배경**

  - 규모 애플리케이션에서 데이터 흐름을 일관성 있게 관리함으로써 프로그램의 예측가능성(Predictability)을 높이기 위함이었습니다.

- **꼬리 질문 3 - Flux 패턴의 action, dispatcher, store, view에 대해 설명해주세요.**

  ⇒ **action** : 데이터를 변경하는 행위로서 dispatcher에 전달되는 객체를 말한다. Action.creator 메서드는 새로 발생한 action의 타입과 새로운 데이터를 묶어 dispatcher에 전달한다.
  **dispatcher** : 모든 데이터의 흐름을 관리하는 중앙 허브로, store들이 등록해놓은 action 타입마다의 콜백 함수들이 존재하며, action을 감지하면 store들이 각 타입에 맞는 store의 콜백 함수를 실행한다.
  **store** : 상태 저장소로 상태와 상태를 변경할 수 있는 메서드를 가지고 있다. 어떤 타입의 action이 발생했는지에 따라 그에 맞는 데이터 변경을 수행하는 콜백 함수를 dispatcher에 등록하고, dispatcher에서 콜백 함수를 실행해 상태가 변경되면 view에 데이터가 변경되었음을 알린다.
  **view** : store에서 view에게 상태가 변경되었음을 알려주면, 최상위 view는 store에서 데이터를 가져와 자식 view에게 내려보내 화면을 리렌더링한다.
