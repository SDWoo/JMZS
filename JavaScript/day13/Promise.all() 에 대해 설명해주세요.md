# Promise.all() 에 대해 설명해주세요.

<br />

> 목차

> [동우](#동우)

> [은지](#은지)

> [지연](#지연)

> [규란](#규란)

<br />

## 동우

여러개의 비동기 처리 프로미스들을 병렬로 사용하려할 때 사용합니다. 병렬로 비동기 처리를 해주기 때문에, 전체 실행 시간은 더욱 빨라질 수 있다. Promise.all은 실행 중간에 한 프로미스 에서 에러가 나면 즉시 동작이 종료된다. 에러처리를 잘 해줘야 한다는 주의점이 있다. 비동기 처리가 끝나는 시간의 순서는 보장되지 않는다.

<br />

## 은지

여러 개의 비동기 처리를 모두 병렬 처리할 때 사용한다.

promise들 중 먼저 실행이 끝난 promise가 있더라도 순서를 지켜 실행한다.

하지만 promise 중 reject를 반환하는 promise가 있다면 에러를 발생시키고 모든 promise는 무시되며 종료된다.

즉, promise.all에 전달되는 promise 중 하나라도 거부되면 promise.all이 반환하는 promise는 에러와 함께 바로 거부된다.

<br />

## 지연

<br />

## 규란

promise.all()은 promise가 담겨있는 배열 등의 이터버를을 인자로 전달받아서, 모든 프로미스를 병렬로 처리하고, 그 처리 결과를 resolve 혹은 reject하는 새로운 프로미스를 반환합니다. 모든 promise가 성공한 경우, 처리 순서가 보장되지만, 하나라도 실패한 경우 가장 먼저 실패한 promise가 reject한 에러를 담아 새롭게 reject하는 promise를 반환합니다.

- 모든 프로미스의 처리가 성공하면 **각각의 프로미스가 resolve한 처리 결과를 배열에 담아 resolve하는 새로운 프로미스를 반환**한다. 이때 첫번째 프로미스가 가장 나중에 처리되어도 Promise.all 메소드가 반환하는 프로미스는 첫번째 프로미스가 resolve한 처리 결과부터 차례대로 배열에 담아 그 배열을 resolve하는 새로운 프로미스를 반환한다. 즉, **처리 순서가 보장된다.**
- 프로미스의 처리가 하나라도 실패하면 가장 먼저 실패한 프로미스가 reject한 에러를 reject하는 새로운 프로미스를 즉시 반환한다.

### then 메소드의 2번째 콜백함수로 처리하는 방법 vs catch

catch 메서드를 호출하면 내부적으로 then(undefined, onRejected)를 호출합니다.
단, 첫 번째 콜백 함수에서 발생한 에러를 캐치하지 못하고 코드가 복잡해져서 가독성이 좋지 않다는 단점이 있습니다.
catch 메소드를 사용하면 모든 then 메서드를 호출한 이후에 호출하면 비동기 처리에서 발생한 에러(reject 함수가 호출된 상태)뿐만 아니라 then 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있습니다.  then 메서드에 두 번째 콜백 함수를 전달하는 것보다 catch 메서드를 사용하는 것이 가독성이 좋고 명확하다. 따라서 에러 처리는 then 메서드에서 하지 말고 catch 메서드를 사용하는 것을 권장한다.

<br />

### 꼬리 질문 모음

- **꼬리 질문 1 : 모든 Promise를 반환 받고 싶을 때는 어떤 메서드를 써야 할까요?**
  ⇒ Promise.**allSettled**

  - `Promise.all`은 Promise가 하나라도 거절되면 전체를 거절하므로 모든 결과가 필요할 때 `Promise.allSettled` 를 사용한다.
  - 모든 결과를 출력하므로 에러가 발생했을 때 catch문으로 빠지지 않아 catch문을 작성하지 않아도 된다.
  - 또한, 모든 promise가 처리될 때까지 기다린다.
